package com.company.UnitTest;

public class ShortExamples {
    /*
    TDD  법치 세 사지
    1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. (기능이 추가되지 않앗기에 테스트는 실패해야한다.)
    2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위테스트를 작성한다. (컴파일은 해야지...)
    3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. (해당 기능을 구현)

    테스트 코드라고 지저분하게 쓰면 미래에 망한다.
    실제 코드가 변하면 테스트코드도 변한다. 고로 테스트코드도 유지보수성을 갖춰야한다.
    테스트코드의 수정이 어려워질수록 시간은 더 오래 걸리고 실제 코드 짜는 시간보다 테스트의 시간이 더 오래걸리는 악순환이 반복되어진다.
    테스트 코드는 실제 코드 못지 않게 중요하다. 사고와 설계와 주의가 필요하다.

    테스트코드는 변경을 두렵지 않게 해준다. 유연성, 유지보수성, 재사용성을 제공해준다.
    그러기에 테스트코드가 지저분해지면 코드 변경능력이 감소하고 코드 구조를 개선하는 능력도 떨어지게 된다.

    물론 기준은 달라도 된다. 테스트 코드는 실제 코드처럼 효율적일 필요는 없다.

    실제환경에선 자우너이 부족할지 몰라도 테스트에선 그런걸 신경쓰지 않아도 된다.
    assert는 최대한 줄일때 쓸때는 뭐 쓰자

    테스트 함수 하나는 한 개념만 테스트하자.
    이것저것 연속으로 테스트는 피해야 한다.
    분리 분리 그리고 분리

    꺠끗한 테스트는 다음 다섯가지 규칙을 따른다. 일명 F. I. R. S. T.

    Fast
    테스트는 빠르게 돌아야 한다.

    Independent
    각 테스트는 서로 의존하면 안 된다.
    하나가 실패하면 나머지가 실패하는 이은 벌어지면 안된다.

    Repeatable
    테스트는 반복가능해야 한다.
    어떤 환경이던지. 환경탓 할일을 없애야 한다.

    Self-Validation
    테스트는 bool로 결과를 내야 한다. 성공 아니면 실패다.
    통과 여부를 확인하기 위해 로그파일을 읽헤 하면 안된다.

    Timely
    바로바로 코드 구현전에 테스트를 구현하자.
    실제 코드를 짜고 테스트를 짜면 실제 코드는 테스트하기 어렵다 판단할지도 모른다.
    무조건 테스트 먼저 짜고..

     */
}
