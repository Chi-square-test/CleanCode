package com.company.MiniRefactoring;

public class ShortExamples {
    /*
    C1 - 다른 시스템에 저장할 정보는 주석으로 적지 말자. 주석은 코드와 설계에 기술적 설명을 부연할 수단일 뿐이다.

    C2 - 오래된,엉뚱한,잘못된 주석은 날리자. 미래가 이런거면 만들지도 말자.

    C3 - 중복은 내다 버리자.주석은 코드로 설명 못하는것만 적는거다.

    C4 - 잘 적자. 제발 성의 있게

    C5 -  주석이 처리된 코드는 흉물이다. 내다 버리자. 정 필요하면 VCS가 도와줄것.

    E1 - 빌드는 심플하게

    E2 - 단위테스트도 심플하게

    F1 - 인수는 작으면 작을수록 좋다. 4개 이상은 진지하게 고민해보자.

    F2 - 출력인수는 문제가 있다.

    F3 - 플래그 인수는 기능이 여러개면 이건 분리를 해야한다.

    F4 - 죽은 함수는 제때제떄 지우자.

    G1 - 한 소스파일엔 하나의 언어만

    G2 - 당연한 동작은 구현해야한다. 직관적으로

    G3 - 코드의 경계는 깔끔하게

    G4 - 안전절차는 확실히 지키자.

    G5 -  매우매우매우매우 중요하다. 코드의 중복은 확실히 치워버려야 한다.
          중복을 발견하면 이건 추상화를 할 수 있는 기회이다. 하위루틴이나 다른 클래스로 분리하자. 구현이 빨라지고 오류가 줄어든다.
          간단한 로직 중복은 함수화 하자. 애매하게 switch나 case, if문 같은걸로 중복 조건체크는 다형성으로 대체해야 한다.
          알고리즘이 미묘하게 비슷하지만 다른건 템플릿 메서드 패턴이나 strategy패턴으로 처리하자.
          중복은 반드시 치우자.

    G6 - 주상화는 잘 하자. 개념을 분리할떈 저차원은 파생 클래스에, 고차원은 기초에 넣는다.

    G7 - 기초 클래스가 파생클래스에 의존하면 안된다.

    G8 - 노출할 함수를 제한하자. 메서드 자체는 적을수록 좋다. 흐기고 그 적은 메서드로 많은 동작이 가능하다. 내부 변수와 유틸리티 함수를 숨겨하. 상수, 임시변수도 숨겨라.메서드나 임시변수가 넘쳐나는건 피하라.
         인터페이스를 매우 작게 그리고 매우 깐깐하게 만들어라.

    G9 - 실행되지 않는 코드는 죽은 코드이다. 불가능한 오류나 case문은 장례식을 잘 치뤄주다.

    G10 -  변수와 함수는 사용되는 위치에 가깝게 정의하자. 비공개는 호출 직후에 정의하자.

    G11 - 비슷하면 비슷하게 구현해야 한다.

    G12 - 쓰잘떼기 없는 잡동사니 코드들도 치우자.

    G13 - 무관한 개념은 결합하지 말자. 일반적으로 enum은 어디에 속할 클래스가 아니다. 범용 static함수도 마찬가지다.

    G14 - 클래스 메서드는 사지 클래수의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가지지 말자.
          메서드가 다른 객체의 참조자와 변경자를 사용해 그 객체 내용을 조작한다면 그건 월권이다.

    G15 - 함수 호출 끝에 false 인수 달지좀 말자. 쪼개자 쪼개. 임수를 넘겨서 동작을 선택하려는 거 자체가 글러먹은거다.

    G16 - 의도를 최대한 밝혀 코드를 짜야 한다.

    G17 - 코드는 자연스러운 위치에 배치해야한다.

    G18 - static는 남발하지 말자. 확실하면 static을 쓰되 애매하면 그냥 인스턴스 함수로 쓰자.

    G19 - 계산을 여러단계로 나누고 중간중간 그걸 변수화하여 이름을 매기자. 읽기 좋다.

    G20 - 이름과 기능은 일치해야한다.

    G21 - 알고리즘은 잘 파악하자.

    G22 - 논리적 의존성은 물리적으로 드러내자.

    G23 - if/else/switch 보단 다형성을 활용하자. switch는 보통 편의에 의해 선택되어지고 함수가 더 쉽게 바뀌는 경우는 드물다.

    G24 - 표준표기법을 좀 따르자.

    G25 - 매직 숫자는 명명된 상수로 바꾸자(이펙티브 자바에도 있다.)

    G26 - 정확해야한다.

    G27 - 관례보단 구조로 확실히 하자.

    G28  - 조건을 캡슐화하자. 조건의 의도를 분병히 밝히자.

    G29 - 부정 조건(!)은 피하자. 긍정보다 이해하기 어렵다.

    G30 - 함수는 한가지만 해야한다.

    G31 - 순서는 잘 표현하자. 시간적인 결합을 노출해야 한다. 순서를 바꿔 호출할 수 없게끔.

    G32 - 일관성은 유지되어야한다.

    G33 - 경계 조건은 캡슐화하여야 한다.확실히 변수화 해서 캡슐로 만들자.

    G34 - 함수는 추상화 수준을 한단계만 내려가야 한다.

    G35 -  설정정보는 최상위에 두어야 한다.

    G36 - 추이적 탐색을 피해야 한다. 디미터의 법칙을 잘 기억하자.

    J1 - 긴 import를 피하고 와일드카드를 사용하자.

    J2 - 상수는 상속하지 말자. 대신 static import를 이용하자.

    J3 - enum은 신이다.

    N1 - 변수에 서술적인 이름을 적지 말자.

    N2 - 적절한 추상화를 하여 이름을 짓자.

    N3 - 가급적 표준병병법을 쓰자.

    N4 - 이름은 명확하게 짓자.

    N5 - 긴 범위는 긴 이름을 쓰자.

    N6 - 인코딩은 피하자. 접두어 접미어 다 치우자.

    N7 - 이름으로 부수효과를 설명하자.

    T1 - 모든 잠재적인 부분을 검증해야한다.

    T2 - 커버리지 도구를 사용하자.

    T3 - 사소한 테스트를 건너뛰지 말자.

    T4 - 무시한 테스트는 뭔가 조진거다.

    T5 - 경계 조건을 테스트하라.(코테 역시 마찬가지)

    T6 - 버그 주변은 철저히 테스트하자.

    T7 - 실패 패턴은 잘 확인하자.

    T8 - 테스트 커버리지 패턴을 잘 확인하자.

    T9 - 테스트는 빨라야 한다.

     */
}
