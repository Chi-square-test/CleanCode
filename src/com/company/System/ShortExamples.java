package com.company.System;

public class ShortExamples {
/*
    관심사 분리는 아주 중요하다.
    제작과 사용은 엄연히 다른 관심사이다.
    특정함수(){
        service = new MyServiceImpl
    }
    이런 초기화 지연 코드는 해덩 new객체와 그에 대한 인수에 의존하게 된다.

    - Main 분리
    생성과 관련된 코드는 모두 main이나 main이 호출하는 모듈로 옮기고 나머지 시스템은 모두 생성되었고 의존성이 연결되었다고 가정하게 한다.
    실제 서비스는 객체 생성 과정을 알 수도 알 이유도 없다. 그저 있다고 가정 한다.

    - 팩토리
    때로는 객체 생성 시점을 정하긴 해야할 수도 있다.
    그럴때는 추상 팩토리 패턴을 이용하여 특정 객체의 생성을 관장하는 인터페이스를 제작하여 생성을 위임한다.
    그러면 서비스가 객체를 요청해서 만들수는 있지만 그 과정역시 감춰지게 된다.

    -의존성 주입(DI)
    의존성 주입은 제어역전(IoC) 기법을 의존성 관리에 적용하는 매커니즘이다.
    제어역전에서는 한 객체가 맡은 보조 책임을 새로운 개체에 떠넘긴다.
    새로운 객체는 넘겨받은 책임만 맡는다. 즉 객체는 인스턴스를 만드는 책임을 지지 않는다.
    이런 매커니즘은 특수 컨테이너를 사용한다. 스프링에서는 이를 Bean 컨테이너가 담당하고 있다.
    DI 컨테이너는 필요한 객체으 신스턴스를 만들어 생성자 인수나 설정자 메서드를 사용해 의존성을 설정한다.
    @RequiredArgsConstructor 어노테이션은 final 인자의 생성자를 자동으로 만들어준다.

    TDD 시스템 아키텍처를 구축하고 의사 결정을 최적화하라.

    그리고 명백한 가치가 있을때 표준을 현명하게 사용하라. 너무 집착하진 말고

    결국 시스템은 깨끗하게 사용해야 한다.

 */
}
